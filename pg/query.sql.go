// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package pg

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (name, logo) VALUES ($1, $2) RETURNING id, name, logo, created_at, updated_at
`

type CreateCustomerParams struct {
	Name string
	Logo pgtype.Text
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, createCustomer, arg.Name, arg.Logo)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Logo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password) VALUES ($1, $2) RETURNING id, email, password, created_at, updated_at
`

type CreateUserParams struct {
	Email    string
	Password string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Email, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWorkOrder = `-- name: CreateWorkOrder :one
INSERT INTO work_orders (customer_id, status, type) VALUES ($1, $2, $3) RETURNING id, customer_id, status, type, created_at, updated_at
`

type CreateWorkOrderParams struct {
	CustomerID int32
	Status     string
	Type       string
}

func (q *Queries) CreateWorkOrder(ctx context.Context, arg CreateWorkOrderParams) (WorkOrder, error) {
	row := q.db.QueryRow(ctx, createWorkOrder, arg.CustomerID, arg.Status, arg.Type)
	var i WorkOrder
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Status,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM customers WHERE id = $1
`

func (q *Queries) DeleteCustomer(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCustomer, id)
	return err
}

const deleteCustomerWorkOrders = `-- name: DeleteCustomerWorkOrders :exec
DELETE FROM work_orders WHERE customer_id = $1
`

func (q *Queries) DeleteCustomerWorkOrders(ctx context.Context, customerID int32) error {
	_, err := q.db.Exec(ctx, deleteCustomerWorkOrders, customerID)
	return err
}

const deleteWorkOrder = `-- name: DeleteWorkOrder :exec
DELETE FROM work_orders WHERE id = $1
`

func (q *Queries) DeleteWorkOrder(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteWorkOrder, id)
	return err
}

const getCustomer = `-- name: GetCustomer :one
SELECT id, name, logo FROM customers WHERE id = $1
`

type GetCustomerRow struct {
	ID   int32
	Name string
	Logo pgtype.Text
}

func (q *Queries) GetCustomer(ctx context.Context, id int32) (GetCustomerRow, error) {
	row := q.db.QueryRow(ctx, getCustomer, id)
	var i GetCustomerRow
	err := row.Scan(&i.ID, &i.Name, &i.Logo)
	return i, err
}

const getCustomerLogo = `-- name: GetCustomerLogo :one
SELECT logo FROM customers WHERE id = $1
`

func (q *Queries) GetCustomerLogo(ctx context.Context, id int32) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getCustomerLogo, id)
	var logo pgtype.Text
	err := row.Scan(&logo)
	return logo, err
}

const getFilteredWorkOrders = `-- name: GetFilteredWorkOrders :many
SELECT wo.id, c.name as customer, status, type FROM work_orders wo
	JOIN customers c ON c.id = wo.customer_id
	WHERE wo.status IN ($1, $2, $3, $4, $5, $6)
`

type GetFilteredWorkOrdersParams struct {
	Status   string
	Status_2 string
	Status_3 string
	Status_4 string
	Status_5 string
	Status_6 string
}

type GetFilteredWorkOrdersRow struct {
	ID       int32
	Customer string
	Status   string
	Type     string
}

func (q *Queries) GetFilteredWorkOrders(ctx context.Context, arg GetFilteredWorkOrdersParams) ([]GetFilteredWorkOrdersRow, error) {
	rows, err := q.db.Query(ctx, getFilteredWorkOrders,
		arg.Status,
		arg.Status_2,
		arg.Status_3,
		arg.Status_4,
		arg.Status_5,
		arg.Status_6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilteredWorkOrdersRow
	for rows.Next() {
		var i GetFilteredWorkOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.Customer,
			&i.Status,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, email FROM users WHERE email = $1 AND password = $2
`

type GetUserParams struct {
	Email    string
	Password string
}

type GetUserRow struct {
	ID    int32
	Email string
}

func (q *Queries) GetUser(ctx context.Context, arg GetUserParams) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, arg.Email, arg.Password)
	var i GetUserRow
	err := row.Scan(&i.ID, &i.Email)
	return i, err
}

const getUserPassword = `-- name: GetUserPassword :one
SELECT password FROM users WHERE email = $1
`

func (q *Queries) GetUserPassword(ctx context.Context, email string) (string, error) {
	row := q.db.QueryRow(ctx, getUserPassword, email)
	var password string
	err := row.Scan(&password)
	return password, err
}

const getWorkOrder = `-- name: GetWorkOrder :one
SELECT wo.id, wo.type, wo.status, c.name as customer FROM work_orders wo
	JOIN customers c ON c.id = wo.customer_id
	WHERE wo.id = $1
`

type GetWorkOrderRow struct {
	ID       int32
	Type     string
	Status   string
	Customer string
}

func (q *Queries) GetWorkOrder(ctx context.Context, id int32) (GetWorkOrderRow, error) {
	row := q.db.QueryRow(ctx, getWorkOrder, id)
	var i GetWorkOrderRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.Customer,
	)
	return i, err
}

const getWorkOrders = `-- name: GetWorkOrders :many
SELECT wo.id, c.name as customer, status, type FROM work_orders wo
	JOIN customers c ON c.id = wo.customer_id
`

type GetWorkOrdersRow struct {
	ID       int32
	Customer string
	Status   string
	Type     string
}

func (q *Queries) GetWorkOrders(ctx context.Context) ([]GetWorkOrdersRow, error) {
	rows, err := q.db.Query(ctx, getWorkOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorkOrdersRow
	for rows.Next() {
		var i GetWorkOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.Customer,
			&i.Status,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomers = `-- name: ListCustomers :many
SELECT id, name, logo FROM customers
`

type ListCustomersRow struct {
	ID   int32
	Name string
	Logo pgtype.Text
}

func (q *Queries) ListCustomers(ctx context.Context) ([]ListCustomersRow, error) {
	rows, err := q.db.Query(ctx, listCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCustomersRow
	for rows.Next() {
		var i ListCustomersRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Logo); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listForecast = `-- name: ListForecast :many
SELECT c.id, c.name, COUNT(wo.id) as count FROM customers c
	LEFT JOIN work_orders wo ON c.id = wo.customer_id AND wo.type = 'pm'
	GROUP BY c.id, c.name
	HAVING COUNT(wo.id) > 0
`

type ListForecastRow struct {
	ID    int32
	Name  string
	Count int64
}

func (q *Queries) ListForecast(ctx context.Context) ([]ListForecastRow, error) {
	rows, err := q.db.Query(ctx, listForecast)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListForecastRow
	for rows.Next() {
		var i ListForecastRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE customers SET name = $1, logo = $2 WHERE id = $3 RETURNING id, name, logo, created_at, updated_at
`

type UpdateCustomerParams struct {
	Name string
	Logo pgtype.Text
	ID   int32
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, updateCustomer, arg.Name, arg.Logo, arg.ID)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Logo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateWorkOrder = `-- name: UpdateWorkOrder :one
UPDATE work_orders SET customer_id = $1, status = $2, type = $3 WHERE id = $4 RETURNING id, customer_id, status, type, created_at, updated_at
`

type UpdateWorkOrderParams struct {
	CustomerID int32
	Status     string
	Type       string
	ID         int32
}

func (q *Queries) UpdateWorkOrder(ctx context.Context, arg UpdateWorkOrderParams) (WorkOrder, error) {
	row := q.db.QueryRow(ctx, updateWorkOrder,
		arg.CustomerID,
		arg.Status,
		arg.Type,
		arg.ID,
	)
	var i WorkOrder
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Status,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
